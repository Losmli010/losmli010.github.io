---
title: 封装、继承和多态
date: 2018-08-31 13:33:20
tags: [封装,property,继承,super,多态,单例类]
categories: python
---

#### 封装

封装分为两个层面：

第一层面的封装：创建类和对象时，分别创建两者的名称空间。只能通过类名.属性或者对象名.属性的方式访问。

```python
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age
        
losmli = Person('亚瑟', '男')
print(losmli.name)		#亚瑟
```



第二层面的封装：类中把某些属性和方法隐藏起来，或者定义为私有，只在类的内部使用，在类的外部无法访问，或者留下少量的接口(函数)供外部访问。

但无论哪种层面的封装，都要对外界提供好访问内部隐藏内容的接口（接口可以理解为入口，有了这个入口，使用者无需且不能够直接访问到内部隐藏的细节，只能走接口，并且可以在接口的实现上附加更多的处理逻辑，从而严格控制使用者的访问） 。



##### 私有化

Python中私有化的方法即在准备私有化的属性名字前面加两个下划线即可。

```python
class Person(object):
    def __init__(self, name, age):
        self.__name = name
        self.__age = age

    def __str__(self):
        #只有在类内部才可以通过__name的形式访问到，外部访问将抛出异常
        return self.__name
    
losmli = Person('亚瑟', '男')
print(losmli)    			#亚瑟
print(losmli.__name)		#AttributeError: 'Person' object has no attribute '__name'
```



##### @property

Python内置的@property装饰器可以把一个方法变成属性调用。被propery装饰的属性分成三种：property、被装饰的函数名.setter、被装饰的函数名.deleter。

```python
class Person(object):
    # 查看age的值
    @property
    def age(self):
        return self.__age

    # 设置age的值
    @age.setter
    def age(self, value):
        # 在设定值之前进行类型检查
        if not isinstance(value, int):
            raise TypeError('age must be an integer!')
        # 取值限定检查
        if value < 0 or value > 150:
            raise ValueError('age must between 0 ~ 150!')
        self.__age = value

losmli = Person()
#设置age的值
losmli.age = 18
#查看age的值
print(losmli.age)		#18
losmli.age = -1			#ValueError: age must between 0 ~ 150!
```



#### 继承

##### 继承和抽象

抽象是分析和设计过程中抽取出共同点，划分类别，得到我们想要的类。继承是基于抽象的结果，通过编程语言去表达出抽象的结构。



继承是一种创建新的类的方式，新建的类可以继承一个或多个父类，原始类成为基类或超类，新建的类则称为派生类或子类。



##### 单继承

通过继承的方式子类获得了父类的全部功能 ，并实现代码重用。同时，子类可以定义自己独有的功能。 

```python
# 定义父类Animal
class Animal(object):
    def run(self):
        print('Animal is running...')


# 定义Dog类直接从Animal类继承
class Dog(Animal):
    pass


# 定义Cat类直接从Animal类继承
class Cat(Animal):
    pass


# 由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，就自动拥有了run()方法
dog = Dog()
dog.run()  # Animal is running...

cat = Cat()
cat.run()  # Animal is running...


class Cat(Animal):
    # Cat类重写父类Animal的run方法
    def run(self):
        print('Cat is running...')

    # 给Cat类增加sleep方法
    def sleep(self):
        print('Sleep all day...')


# 当子类和父类都存在相同的run()方法时，子类的run()覆盖了父类的run()，即重写父类方法
miao = Cat()
miao.run()      #Cat is running...
```



##### 多继承

在设计类的继承关系时，通常，主线都是单一继承下来的。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，这种设计通常称之为Mixin。 Python自带的很多库也使用了Mixin。举个例子Python自带了TCPServer和UDPServer这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由ForkingMixin和ThreadingMixin提供。通过组合，我们就可以创造出合适的服务来。 

```python
#编写一个多进程模式的TCP服务
class MyTCPServer(TCPServer, ForkingMixin):
    pass
```



##### super

子类继承了父类的方法，然后想进行修改，注意了是基于原有的基础上修改，那么就需要在子类中调用父类的

方法。

```python
class A(object):
    def __init__(self):
        self.n = 2

    def add(self, m):
        print('self is {0} @A.add'.format(self))
        self.n += m

#当我们调用 super() 的时候，实际上是实例化了一个super类。即super是一个类
x = super(A)
print(type(x))      #<class 'super'>

class B(A):
    def __init__(self):
        self.n = 3

    def add(self, m):
        print('self is {0} @B.add'.format(self))
        super().add(m)
        self.n += 3

#单继承中的super
b = B()
b.add(3)
print(b.n)
"""
self is <__main__.B object at 0x00000204912D9D68> @B.add
self is <__main__.B object at 0x00000204912D9D68> @A.add
9
"""
#子类中super会调用父类的方法，但此时父类中的self并不是父类的实例而是子类的实例

class C(A):
    def __init__(self):
        self.n = 4

    def add(self, m):
        print('self is {0} @C.add'.format(self))
        super().add(m)
        self.n += 4

class D(B, C):
    def __init__(self):
        self.n = 5

    def add(self, m):
        print('self is {0} @D.add'.format(self))
        super().add(m)
        self.n += 5

##多继承中的super
d = D()
d.add(5)
print(d.n)
print(D.mro())
"""
self is <__main__.D object at 0x00000197172C99E8> @D.add
self is <__main__.D object at 0x00000197172C99E8> @B.add
self is <__main__.D object at 0x00000197172C99E8> @C.add
self is <__main__.D object at 0x00000197172C99E8> @A.add
22
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
"""
```



##### 函数重写

Python3中如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法的实现，可以重写这些方法。

```python
class Student(object):
    #重写object中的init方法
    def __init__(self, name):
        self.name = name

    #打印实例，返回字符串
    def __str__(self):
        return self.name

    #正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错
    #当调用不存在的属性时，Python解释器会试图调用__getattr__(self, attr)来尝试获得属性
    def __getattr__(self, attr):
        if attr == 'age':
            return 18
        raise AttributeError('\'Student\' object has no attribute \'%s\'' % attr)

    #任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用
    def __call__(self):
        print('My name is %s.' % self.name)

stu = Student('李白')
print(stu)          #李白
print(stu.age)      #18
print(stu.sex)      #AttributeError: 'Student' object has no attribute 'sex'
stu()               #My name is 李白.
```



重写new方法来实现单例类

```python
class Singleton(object):
    instance = None
    def __new__(cls, *args, **kwargs):
        if not cls.instance:
            cls.instance = object.__new__(cls)
        return cls.instance

class MySingleton(Singleton):
    def __init__(self, name):
        self.name = name

a = MySingleton('韩信')
b = MySingleton('李白')
print(a is b)           #True
```



#### 多态

多态指的是一类事物有多种形态，（一个抽象类有多个子类，因而多态的概念依赖于继承）。 比如，动物分为猫类和狗类。

```python
import abc

# 同一类事物：动物
class Animal(metaclass=abc.ABCMeta):
    # 要求子类必须实现call功能
    @abc.abstractmethod
    def call(self):
        pass

# 动物的形态之一：猫
class Cat(Animal):
    def call(self):
        print('call miaomiao')

# 动物的形态之二：狗
class Dog(Animal):
    def call(self):
        print('call wangwang')

#实例化对象
cat = Cat()
dog = Dog()

# 定义一个函数，相当于一个接口
# 传来不同的实例化对象，最后实现的结果也不一样
def func(obj):
    obj.call()

#多态性：同一种调用方式，不同的执行效果
# 以下虽然对象不一样，但是调用的方法是一样的，这就是多态性
func(cat)       #call miaomiao
func(dog)       #call wangwang

#新增一种动物类：猪
class Pig(Animal):
    def call(self):
        print("call hengheng")

pig = Pig()
#调用函数(接口) 无需再自己定义，直接调用接口就行
func(pig)   #call hengheng
```



#### 参考资料

[Python基础之封装][1]

[Python中super的应用][2]

[1]: https://www.cnblogs.com/Michael--chen/p/6740455.html
[2]: https://www.cnblogs.com/dengshihuang/p/8136908.html

