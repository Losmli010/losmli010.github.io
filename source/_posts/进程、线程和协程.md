---
title: 进程、线程和协程
date: 2018-09-05 08:49:29
tags: [进程,多线程,协程]
categories: 网络编程
---

#### 并发和并行

并发和并行是进行多任务处理的两种不同方式。

并发是CPU交替执行多个任务，由于CPU的处理速度非常快，宏观上看起来，多个任务被同时执行，而微观上，任意时刻只有一个任务被CPU执行。

并行是多个CPU来执行多个任务。



#### 同步和异步

同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去。

异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。



#### 进程

计算机程序只是存储在磁盘上的可执行二进制（或其他类型）文件。只有把它们加载到内存中并被操作系统调用，才拥有其生命期。进程则是一个执行中的程序。每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。进程也可以通过派生 （fork 或 spawn）新的进程来执行其他任务，不过因为每个新进程也都拥有自己的内存和数据栈等，所以只能采用进程间通信（IPC）的方式共享信息。 

进程是操作系统分配资源（内存资源和I/O资源）的基本单位。



#### 线程

线程与进程类似，不过线程是在同一个进程下执行的，并共享相同的上下文。 线程包括开始、执行顺序和结束三部分。它有一个指令指针，用于记录当前运行的上下 文。当其他线程运行时，它可以被抢占（中断）和临时挂起（也称为睡眠）——这种做法叫做让步（yielding）。 一个进程中的各个线程与主线程共享同一片数据空间，因此相比于独立的进程而言，线程间的信息共享和通信更加容易。线程一般是以并发方式执行的，正是由于这种数据共享机制，使得多任务间的协作成为可能。当然，在单核 CPU 系统中，因为真正的并发是不可能的，所以线程的执行实际上是这样规划的：每个线程运行一小会儿，然后让步给其他线程（再次排队等待更多的 CPU 时间）。在整个进程的执行过程中，每个线程执行它自己特定的任务，在必要时和其他线程进行结果通信。 当然，这种共享并不是没有风险的。如果两个或多个线程访问同一片数据，由于数据访问顺序不同，可能导致结果不一致。这种情况通常称为竞态条件（race condition）。幸运的是， 大多数线程库都有一些同步原语，以允许线程管理器控制执行和访问。 

线程是程序执行时的最小单位，它是进程的一个执行流，是CPU调度和分派的基本单位。一个进程可以由很多个线程组成，且有且仅有一个主线程，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。 



#### 全局解释器锁

Python 代码的执行是由 Python 虚拟机（又名解释器主循环）进行控制的。Python 在设计时是这样考虑的，在主循环中同时只能有一个控制线程在执行，就像单核 CPU 系统中的多进程一样。内存中可以有许多程序，但是在任意给定时刻只能有一个程序在运行。 同理，尽管 Python 解释器中可以运行多个线程，但是在任意给定时刻只有一个线程会被解释器执行。 

对 Python 虚拟机的访问是由全局解释器锁（GIL）控制的。这个锁就是用来保证同时只能有一个线程运行的。在多线程环境中，Python 虚拟机将按照下面所述的方式执行。 1．设置 GIL。 2．切换进一个线程去运行。 3．执行下面操作之一。 a．指定数量的字节码指令。 b．线程主动让出控制权（可以调用 time.sleep(0)来完成）。 4．把线程设置回睡眠状态（切换出线程）。 5．解锁 GIL。 6．重复上述步骤。 当调用外部代码（即，任意 C/C++扩展的内置函数）时，GIL 会保持锁定，直至函数执 行结束（因为在这期间没有 Python 字节码计数）。

 例如，对于任意面向 I/O 的 Python 例程（调用了内置的操作系统 C 代码的那种）， GIL 会在 I/O 调用前被释放，以允许其他线程在 I/O 执行的时候运行。而对于那些没有太多 I/O 操作的代码而言，更倾向于在该线程整个时间片内始终占有处理器（和 GIL）。换句话说就是，I/O 密集型的 Python 程序要比计算密集型的代码能够更好地利用多线程环境。

 

#### 多线程

##### 单线程

```python
import time

#休眠时间
seconds = [3, 2, 4]

#创建任务
def work(second):
    print('start work at: %s' % (time.ctime()))
    time.sleep(second)
    print('end work at: %s' % (time.ctime()))

#单线程执行任务
def main():
    print('All work start at: %s' % time.ctime())
    #顺序执行多任务
    for i in range(len(seconds)):
        work(seconds[i])

    print('All work done at: %s' % time.ctime())

if __name__ == '__main__':
    main()
    
"""
All work start at: Sat Sep  1 11:21:24 2018
start work at: Sat Sep  1 11:21:24 2018
end work at: Sat Sep  1 11:21:27 2018
start work at: Sat Sep  1 11:21:27 2018
end work at: Sat Sep  1 11:21:29 2018
start work at: Sat Sep  1 11:21:29 2018
end work at: Sat Sep  1 11:21:33 2018
All work done at: Sat Sep  1 11:21:33 2018
"""
#一共耗时9s，seconds = [3, 2, 4]
```



##### 创建多线程

###### 创建Thread的实例，传给它一个函数

```python
from threading import Thread, current_thread
import time

#休眠时间
seconds = [3, 2, 4]

#创建单个线程任务
def work(second):
    print('%s start work at: %s' % (current_thread().name, time.ctime()))
    time.sleep(second)
    print('%s end work at: %s' % (current_thread().name, time.ctime()))

#多线程执行
def main():
    # 主线程
    print('%s start work at: %s' % (current_thread().name, time.ctime()))
    threads = []
    #创建多个子线程
    nloop = len(seconds)
    for i in range(nloop):
        #创建Thread的实例，传给它一个函数
        t = Thread(target=work, args=(seconds[i],))
        threads.append(t)

    #开启子线程
    for i in range(nloop):
        threads[i].start()

    #等待所有子线程结束
    for i in range(nloop):
        threads[i].join()

    print('%s end work at: %s' % (current_thread().name, time.ctime()))

if __name__ == '__main__':
    main()
    
"""
MainThread start work at: Sat Sep  1 11:24:14 2018
Thread-1 start work at: Sat Sep  1 11:24:14 2018
Thread-2 start work at: Sat Sep  1 11:24:14 2018
Thread-3 start work at: Sat Sep  1 11:24:14 2018
Thread-2 end work at: Sat Sep  1 11:24:16 2018
Thread-1 end work at: Sat Sep  1 11:24:17 2018
Thread-3 end work at: Sat Sep  1 11:24:18 2018
MainThread end work at: Sat Sep  1 11:24:18 2018
"""
#一共耗时4s
```



###### 派生Thread的子类，并创建子类的实例

```python
import time
from threading import Thread, current_thread

#派生Thread的子类
class MyThread(Thread):
    def __init__(self, func, args, name=None):
        #调用父类init方法并重写
        super().__init__()
        self.func = func
        self.args = args
        self.name = name

    #定义每个线程要运行的函数
    def run(self):
        self.func(*self.args)

#休眠时间
seconds = [3, 2, 4]

#创建单个线程任务
def work(second):
    print('%s start work at: %s' % (current_thread().name, time.ctime()))
    time.sleep(second)
    print('%s end work at: %s' % (current_thread().name, time.ctime()))

#多线程执行
def main():
    # 主线程
    print('%s start work at: %s' % (current_thread().name, time.ctime()))
    threads = []
    #创建多个子线程
    nloop = len(seconds)
    for i in range(nloop):
        #通过派生Thread的子类创建子类的实例
        t = MyThread(func=work, args=(seconds[i],), name='Thread-%d' % (i + 1))
        threads.append(t)

    #开启子线程
    for i in range(nloop):
        threads[i].start()

    #等待所有子线程结束
    for i in range(nloop):
        threads[i].join()

    print('%s end work at: %s' % (current_thread().name, time.ctime()))

if __name__ == '__main__':
    main()
    
"""
MainThread start work at: Sat Sep  1 11:28:29 2018
Thread-1 start work at: Sat Sep  1 11:28:29 2018
Thread-2 start work at: Sat Sep  1 11:28:29 2018
Thread-3 start work at: Sat Sep  1 11:28:29 2018
Thread-2 end work at: Sat Sep  1 11:28:31 2018
Thread-1 end work at: Sat Sep  1 11:28:33 2018
Thread-3 end work at: Sat Sep  1 11:28:33 2018
MainThread end work at: Sat Sep  1 11:28:33 2018
"""
```



##### 同步原语

多线程执行时，如果两个线程运行的顺序发生变化，就有可能造成代码的执行轨迹或行为不相同，或者产生不一致的数据 。通常在修改数据库、更新文件或其他会产生竞态条件的类似情况下，如果多个线程同时执行，产生的数据结果将会是不确定的，因此需要给定的时刻只有一个线程可以执行，保证程序结果的确定性，这时候就可以使用同步原语了。

###### 锁/互斥

锁有两种状态：锁定和未锁定。而且它也只支持两个函数：获得锁和释放锁。 

当多线程争夺锁时，允许第一个获得锁的线程进入临界区，并执行代码。所有之后到达的线程将被阻塞，直到第一个线程执行结束，退出临界区，并释放锁。此时，其他等待的线程可以获得锁并进入临界区。不过请记住，那些被阻塞的线程是没有顺序的（即不是先到先执行），胜出线程的选择是不确定的。 

```python
from threading import Thread, current_thread, Lock
import time

#公共资源
arr = []

#创建锁
lock = Lock()

#休眠时间
seconds = [3, 2, 4]

#创建单个线程函数
def work(second):
    name = current_thread().name
    print('%s start work at: %s' % (name, time.ctime()))
    # 添加资源
    #加锁
    lock.acquire()
    arr.append(name)
    print('All source is %s' % arr)
    #释放锁
    lock.release()
    time.sleep(second)

    #删除资源
    lock.acquire()
    arr.pop()
    print('All source is %s' % arr)
    lock.release()
    time.sleep(second)

    print('%s end work at: %s' % (current_thread().name, time.ctime()))

#多线程执行
def main():
    # 主线程
    print('%s start work at: %s' % (current_thread().name, time.ctime()))
    threads = []
    #创建多个子线程
    nloop = len(seconds)
    for i in range(nloop):
        #创建Thread的实例，传给它一个函数
        t = Thread(target=work, args=(seconds[i],))
        threads.append(t)

    for i in range(nloop):
        threads[i].start()

    #等待所有子线程结束
    for i in range(nloop):
        threads[i].join()

    print('%s end work at: %s' % (current_thread().name, time.ctime()))

if __name__ == '__main__':
    main()

"""
MainThread start work at: Sat Sep  1 14:17:18 2018
Thread-1 start work at: Sat Sep  1 14:17:18 2018
All source is ['Thread-1']
Thread-2 start work at: Sat Sep  1 14:17:18 2018
All source is ['Thread-1', 'Thread-2']
Thread-3 start work at: Sat Sep  1 14:17:18 2018
All source is ['Thread-1', 'Thread-2', 'Thread-3']
All source is ['Thread-1', 'Thread-2']
All source is ['Thread-1']
Thread-2 end work at: Sat Sep  1 14:17:22 2018
All source is []
Thread-1 end work at: Sat Sep  1 14:17:24 2018
Thread-3 end work at: Sat Sep  1 14:17:26 2018
MainThread end work at: Sat Sep  1 14:17:26 2018
"""
```



###### 信号量

信号量实际上就是计数器，它们从固定数量的有限资源起始。 当分配一个单位的资源时，计数器值减 1，而当一个单位的资源返回资源池时，计数器值加1。  同时只有n个线程可以获得semaphore,即可以限制最大连接数为n 。

```python
import random
from threading import Thread, Lock, BoundedSemaphore
import time

lock = Lock()
#资源数量有限，只有5个杯子可用
MAX = 5
cups = BoundedSemaphore(MAX)

#清洗杯子
def wash():
    global MAX
    lock.acquire()
    try:
        #资源释放，可用杯子数加1
        cups.release()
        MAX += 1
        print('Wash a cup, there are %s cups to be used' % MAX)
    except ValueError as err:
        print(err)
    lock.release()

#使用杯子
def use():
    global MAX
    lock.acquire()
    if cups.acquire(blocking=False):
        MAX -= 1
        print('Use a cup, there are %s cups to be used' % MAX)
    else:
        print('No cup could be used')
    lock.release()

def washer(loops):
    for i in range(loops):
        wash()
        time.sleep(random.randint(1, 3))

def user(loops):
    for i in range(loops):
        use()
        time.sleep(random.randint(1, 3))

def main():
    print('There are %s cups to be used' % MAX)
    loops = random.randint(6, 8)
    Thread(target=user, args=(loops,)).start()
    Thread(target=washer, args=(loops - 5,)).start()

if __name__ == '__main__':
    main()
    
"""
There are 5 cups to be used
Use a cup, there are 4 cups to be used
Wash a cup, there are 5 cups to be used
Semaphore released too many times
Use a cup, there are 4 cups to be used
Wash a cup, there are 5 cups to be used
Use a cup, there are 4 cups to be used
Use a cup, there are 3 cups to be used
Use a cup, there are 2 cups to be used
Use a cup, there are 1 cups to be used
Use a cup, there are 0 cups to be used
No cup could be used
"""
```



##### 生产者-消费者问题

```python
import time
import random
from threading import Thread
from queue import Queue

#制作包子
def make(queue):
    print('Making a baozi...')
    queue.put(1)
    print('There are %d baozi to sell' % queue.qsize())

#贩卖包子
def buy(queue):
    print('Buy a baozi...')
    queue.get(1)
    print('There are %d baozi to buy' % queue.qsize())

#生产者线程
def producer(queue, loops):
    for i in range(loops):
        make(queue)
        time.sleep(random.randint(1, 3))

#消费者线程
def consumer(queue, loops):
    for i in range(loops):
        buy(queue)
        time.sleep(random.randint(1, 3))

funcs = [producer, consumer]
nfuncs = len(funcs)

def main():
    #创建消息队列
    queue = Queue(32)
    threads = []
    for i in range(nfuncs):
        t = Thread(target=funcs[i], args=(queue, 3))
        threads.append(t)

    for i in range(nfuncs):
        threads[i].start()

    for i in range(nfuncs):
        threads[i].join()

if __name__ == '__main__':
    main()
    
"""
Making a baozi...
There are 1 baozi to sell
Buy a baozi...
There are 0 baozi to buy
Making a baozi...
There are 1 baozi to sell
Buy a baozi...
There are 0 baozi to buy
Making a baozi...
There are 1 baozi to sell
Buy a baozi...
There are 0 baozi to buy
"""
```



#### 协程

协程，又称为微线程，看上去像是子程序，但是它和子程序又不太一样，它在执行的过程中，可以在中断当前的子程序后去执行别的子程序，在适当的时候再返回来接着执行。 

###### 同步协程

```python
#制作包子
def make():
    print('Making a baozi...')

#贩卖包子
def buy():
    print('Buy a baozi...')

def consumer():
    receive = ''
    while True:
        num = yield receive
        if not num:
            return
        buy()

def producer(consumer):
    consumer.send(None)
    num = 0
    while num < 3:
        make()
        num += 1
        print('Producing %s baozi now' % num)
        #协程数据传输
        consumer.send(num)
    consumer.close()

if __name__ == '__main__':
    c = consumer()
    producer(c)
    
"""
Making a baozi...
Producing 1 baozi now
Buy a baozi...
Making a baozi...
Producing 2 baozi now
Buy a baozi...
Making a baozi...
Producing 3 baozi now
Buy a baozi...
"""
```



###### 异步协程

```python
import asyncio

# 创建一个类，做汉堡类
class Hamburger(object):
    @classmethod
    def make(cls, n, *args, **kwargs):
        # 创建指定的对象
        hamburgers = [object.__new__(cls) for _ in range(n)]
        return hamburgers

#先制作5个汉堡
hamburgers = Hamburger.make(5)

#生产者
async def producer(pnum):
    await asyncio.sleep(3)
    hamburgers.extend(Hamburger.make(pnum))
    print('There are %d hamburgers to sell' % len(hamburgers))

#消费者
async def consumer(cnum, pnum):
    # 定义一个变量用于统计汉堡的个数
    count = 0
    while True:
        if not hamburgers:
            # 如果没有，根据请求来做汉堡
            await producer(pnum)
        # 取出一个汉堡给客户
        h = hamburgers.pop()
        asyncio.sleep(2)
        yield h
        count += 1
        # 如果n个汉堡都做完了结束循环
        if count == cnum:
            break

# 定义一个函数来买汉堡
async def buy(cnum, pnum):
    b = []
    async for h in consumer(cnum, pnum):
        b.append(h)
        print('Buy %d hamburgers' % len(b))


if __name__ == '__main__':
    # 开启异步循环
    loop = asyncio.get_event_loop()
    loop.run_until_complete(buy(10, 4))
    loop.close()
    
"""
Buy 1 hamburgers
Buy 2 hamburgers
Buy 3 hamburgers
Buy 4 hamburgers
Buy 5 hamburgers
There are 4 hamburgers to sell
Buy 6 hamburgers
Buy 7 hamburgers
Buy 8 hamburgers
Buy 9 hamburgers
There are 4 hamburgers to sell
Buy 10 hamburgers
"""
```



#### 参考资料

[Python核心编程][1]

[竞态条件][1]

[1]: https://book.douban.com/subject/26801374/
[2]: https://en.wikipedia.org/wiki/Race_condition

