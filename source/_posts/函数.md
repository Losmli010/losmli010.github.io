---
title: 函数
date: 2018-07-01 21:57:33
tags: [函数,匿名函数,作用域,生成器,yield]
categories: python
---

#### 函数

在Python中，定义函数使用def关键字，依次写出函数名、括号、括号中的参数和冒号，然后，在缩进块中编写函数体，函数的返回值用return语句返回。 

```python
#定义函数
def my_abs(num):
    if num >= 0:
        return num
    else:
        return -num
    
#调用函数
result = my_abs(-1)

"""
函数定义完成代码不会自动执行，只有手动调用才会执行。
手动调用函数，依次书写定义的函数名、括号和实参，并将返回值赋值给一个变量。
函数体内部的语句在执行时，一旦执行到return时，函数就执行结束，并将结果返回。
"""
```

定义函数时，需要确定函数名、参数个数和是否需要返回结果。

 

##### 参数

```python
def add(a, b):
    return a + b

#位置参数：调用函数的时候传入的值按照位置顺序依次赋给参数
total1 = add(1, 2)		#相当于a=1，b=2

#调用函数的时候通过参数名进行传参，不需要按照位置传递
total2 = add(a=2, b=3)		#两种方式等价
total3 = add(b=3, a=2)

#默认参数
"""
必选参数在前，默认参数在后，否则Python的解释器会报错
调用函数的时候，如果没有传递参数，则会使用默认参数
"""
def power(a, b=2):
    return a ** b

result1 = power(2)		 	#4
result2 = power(2, 3)		#8

#不定长参数
"""
*args，args接收的是一个tuple
既可以直接传入func(1, 2, 3)，又可以组成tuple，再通过*args传入func(*(1, 2, 3))
**kwargs，kwargs接收的是一个dict
既可以直接传入func(a=1, b=2)，又可以先组成dict，再通过**kwargs传入func(**{'a': 1, 'b': 2})
"""
def many(*args, **kwargs):
    print(args)
    print(kwargs)
    
many(1, 2, 3, name="Losmli", job="programmer")
many(*(1, 2, 3), **{'name': 'Losmli', 'job': 'programmer'})
#(1, 2, 3)
#{'name': 'Losmli', 'job': 'programmer'}
```



##### 返回值

函数的返回值通过return关键字返回，同时，return会结束函数。

```python
#无return语句，函数执行完毕自动返回None
def func():
    print("Here is no return")
    
result1 = func()		#result1 = None

#return后面无返回值，用来结束函数，结果返回None
def function():
    return

result2 = function()	#result2 = None

#返回一个值
def compare(a, b):
    larger = a
    if larger < b:
        larger = b
    return larger

result3 = compare(2, 3)		#result3 = 3

#返回多个值，返回的是一个tuple
def exchange(a, b):
    temp = a
    a = b
    b = temp
    return a, b		#也可以写成return (a, b)

result4 = exchange(1, 8)		#也可以写成a, b = exchange(1, 8)
#(8, 1)
```



#### 空函数

pass关键字占位，保证代码能正常运行。

```python
def func():
    pass
```



#### 匿名函数

关键字lambda定义匿名函数，lambda 参数列表: 表达式。匿名函数没有函数名，没有return语句，返回值就是表达式的结果。

```Python
#匿名函数没有函数名，但可以将整个匿名函数赋值给一个变量，通过变量调用函数
def add(a, b):
    return a + b

f = lambda a, b: a + b
total = f(1, 2)
```



#### 递归函数

在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。 

```python
#斐波那契数列：1,1,2,3,5,8,13,21,34,55,89...
def fib(n):
    if n <= 2:
        return 1
    return fib(n - 1) + fib(n - 2)

result = fib(4)
```

使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 



#### 高阶函数

##### map

map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的可迭代对象返回。

```python
#map(function,iterable)
#自定义函数
def f(x):
    return x ** 2
result1 = map(f, [1, 2, 3, 4, 5])		#<map object at 0x000001A77C7941D0>
result2 = list(result1)					#[1, 4, 9, 16, 25]

#匿名函数
result3 = list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))

#内置函数
result4 = list(map(str, [1, 2, 3, 4, 5]))	#['1', '2', '3', '4', '5']
```



##### reduce

reduce()函数必须接收两个参数，一个是函数，一个是序列，reduce将传入的函数依次作用到序列的每个元素，reduce把结果继续和序列的下一个元素做累积计算。

```Python
from  functools  import  reduce

def f(x, y):
    return 10 * x + y

result = reduce(f, [2, 4, 1, 7])		#2417
```



##### filter

filter()函数必须接收两个参数，一个是函数，一个是序列，filter将传入的函数依次作用于列表中的每一个元素，根据返回的是True还是False决定元素是否需要保留。

```Python
def is_odd(n):
    return n % 2 == 0

result = list(filter(is_odd, range(10)))
#[0, 2, 4, 6, 8]
```



##### sorted

sorted()函数接收一个比较函数来实现自定义的排序。

```python
result1 = sorted([3, 9, 0, 1, 4])				#[0, 1, 3, 4, 9]
result2 = sorted([3, 9, 0, 1, 4], reverse=True)	 #[9, 4, 3, 1, 0]

#自定义排序函数
list1 = [4, 5, -23, 3, -5, 7]
result3 = sorted(list1,key=abs)		#[3, 4, 5, -5, 7, -23]

#按照字典的值升序排序
dict1 = {"losmli": 20, "jack": 22, "sam": 18, "susan": 24}
result4 = sorted(dict1, key=lambda d:d[1])		#['jack', 'sam', 'losmli', 'susan']
```



#### 全局变量和局部变量

Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。函数定义了局部作用域，而模块定义的是全局作用域。

全局变量定义在函数的外面，可以在整个程序中使用，而局部变量定义在函数的内部，只能在其被声明的当前函数中使用。

```Python
#全局变量
year = 2018

def func():
    #局部变量
    month = 7
    day = 1
    #全局变量在函数内部被使用
    return "today is %d-%d-%d" %(year, month, day)
    
result = func()			#today is 2018-7-1
print(month)			#name 'month' is not defined
```



函数内部使用全局变量时，当全局变量参与运算时，需要使用global关键字，结果全局变量在整个程序中的值也会改变。

```Python
N = 99

def change():
    global N
    N += 1
   	print(N)
    
change()			#100
print(N)			#100
```



#### 生成器

##### 可迭代对象

使用列表生成式来建立一个列表的时候，就建立了一个可迭代的对象 。

列表，字典，元组，字符串，文件……可以通过for循环读取其中的元素，但是把所有的值都存储到了内存中，如果有大量数据的话这个方式并不合适。 

```Python
mylist = [x * x for x in range(3)]
for i in mylist:
    print(i)

"""
0
1
4
"""
```



生成器是可以迭代的，但是一次只能读取一个值 ，因为它并不把所有的值放在内存中，它是实时地生成数据。

```Python
mygenerator = (x * x for x in range(3))
result1 = next(mygenerator)			#0
result2 = next(mygenerator)			#1
result3 = next(mygenerator)			#4
```

不可以再次使用 for i in mygenerator , 因为生成器只能被迭代一次：先计算出0，然后继续计算1，然后计算4，一个跟一个的… 



##### yield

yield 是一个类似 return 的关键字，只是这个函数返回的是个生成器。 

```python
def create_generator():
    for i in range(3):
        print("start")
        yield i * i
        print("end")
        
mygenerator = create_generator()
print(mygenerator)				
#<generator object create_generator at 0x000001D492C36620>
for i in mygenerator:
    print(i)
    
"""
start
0
end
start
1
end
start
4
end
"""
```

当调用这个函数的时候，函数内部的代码并不立马执行 ，只是返回一个生成器对象，当使用for进行迭代的时候，函数内的代码才会开始执行。

生成器一次只返回一个结果，不会生成全部结果，可以节省内存。



#### 回调函数

编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是**应用**。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。

当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。

可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再**回**过头来**调**用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。

在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：

```python
#作者：no.body
#链接：https://www.zhihu.com/question/19801131/answer/27459821


#回调函数1
#生成一个2k形式的偶数
def double(x):
    return x * 2
    
#回调函数2
#生成一个4k形式的偶数
def quadruple(x):
    return x * 4

#中间函数
#接受一个生成偶数的函数作为参数
#返回一个奇数
def getOddNumber(k, getEvenNumber):
    return 1 + getEvenNumber(k)
    
#起始函数，这里是程序的主函数
def main():    
    k = 1
    #当需要生成一个2k+1形式的奇数时
    i = getOddNumber(k, double)
    print(i)
    #当需要一个4k+1形式的奇数时
    i = getOddNumber(k, quadruple)
    print(i)
    #当需要一个8k+1形式的奇数时
    i = getOddNumber(k, lambda x: x * 8)
    print(i)
    
if __name__ == "__main__":
    main()
    
"""
3
5
9
"""
```

上面的代码里，给getOddNumber传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。

通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。

之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。



#### 参考资料

[Python中yield关键字的解释][1]

[1]: https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do